#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
#include <string>
#include <ctime>
#include <map>
#include <list>
#include <queue>
#include <cstring>

using namespace std;

//꿀따기

//아래와 같이 좌우로 $N$개의 장소가 있다.
//
//
//
//장소들 중 서로 다른 두 곳을 골라서 벌을 한 마리씩 둔다.또, 다른 한 장소를 골라서 벌통을 둔다.아래 그림에서 연한 회색의 장소는 벌이 있는 장소이고 진한 회색의 장소는 벌통이 있는 장소이다.
//
//
//
//두 마리 벌은 벌통으로 똑바로 날아가면서 지나가는 모든 칸에서 꿀을 딴다.각 장소에 적힌 숫자는 벌이 지나가면서 꿀을 딸 수 있는 양이다.
//
//두 마리가 모두 지나간 장소에서는 두 마리 모두 표시된 양 만큼의 꿀을 딴다. (벌통이 있는 장소에서도 같다.)
//벌이 시작한 장소에서는 어떤 벌도 꿀을 딸 수 없다.
//위의 그림과 같이 배치된 경우 두 마리의 벌 모두 $4 + 1 + 4 + 9 + 9 = 27$의 꿀을 따서, 전체 꿀의 양은 54가 된다.
//
//
//
//위의 그림과 같이 배치된 경우 왼쪽 장소에서 출발한 벌은 $9 + 4 + 4 + 9 + 9 = 35$의 꿀을 따고 오른쪽 장소에서 출발한 벌은 $4 + 9 + 9 = 22$의 꿀을 따므로, 전체 꿀의 양은 $57$이 된다.
//
//
//
//위의 그림과 같은 경우는 전체 꿀의 양이 31이 된다.
//
//장소들의 꿀 양을 입력으로 받아 벌들이 딸 수 있는 가능한 최대의 꿀의 양을 계산하는 프로그램을 작성하라.

int main(void)
{

	ios_base::sync_with_stdio(0);
	cin.tie(0);

	int n;
	cin >> n;

	vector<int> map(n);
	int total = 0;
	for (int i = 0; i < n; i++)
	{
		cin >> map[i];
		total += map[i];
	}

	int ans = 0;
	int dup; // 두 벌이 중복해서 가져가는 꿀의 양


	//벌 - 꿀 - 벌
	for (int i = 1; i < n; i++)
	{
		dup = map[i];

		//입력받는 꿀의 양은 항상 양수이기 때문에 양쪽끝에서 오는 벌들이 가장 꿀을 많이 가지고있다.
		// 그러므로 벌은 양쪽끝에 있다 가정하고
		// 꿀통만 자리를 옮겨가면서 최대값을 구한다.
		//벌이 있던자리는 꿀을 얻지못하기 때문에
		// 벌이 있는 자리 map[0] map[n-1]값을 빼주고
		// 꿀통이 있는 자리는 2마리에 벌이 꿀을 얻을 수 있기 때문에 dup에 꿀통자리의 값을 넣어주고 더해준다.
		ans = max(ans, total - map[0] - map[n - 1] + dup);
	}

	// 벌 - 벌 - 꿀
	dup = map[n - 1];
	for (int i = n - 2; i > 0; i--)
	{
		//꿀을 오른쪽 끝에 고정
		//벌한마리를 왼쪽끝에 고정 시키고
		//나머지 벌한마리를 꿀위치-1로 위치를 정하고 -1씩 전진시킨다.
		//위에 케이스랑은 다르게 꿀통이 아니라 벌이 움직이는 것이라서
		// 벌이 움직일때마다 꿀을 겹치게 가져가는 경우가 생긴다.
		// 그래서 dup+=벌이 있던위치를 해주는 것이다.
		ans = max(ans, total - map[0] - map[i] + dup);
		dup += map[i];
	}




	// 꿀 - 벌 - 벌
	dup = map[0];
	//위에와 반대의 경우이므로 반대로만 해준다.
	for (int i = 1; i < n - 1; i++)
	{
		ans = max(ans, total - map[n - 1] - map[i] + dup);
		dup += map[i];
	}

	cout << ans;



	return 0;

}