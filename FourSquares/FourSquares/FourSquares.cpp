#include <iostream>
#include <vector>
#include <cstring>
#include <queue>
#include <algorithm>
#include <map>
#include <limits>

using namespace std;

//
//라그랑주는 1770년에 모든 자연수는 넷 혹은 그 이하의 제곱수의 합으로 표현할 수 있다고 증명하였다.어떤 자연수는 복수의 방법으로 표현된다.예를 들면, 26은 52과 12의 합이다; 또한 42 + 32 + 12으로 표현할 수도 있다.역사적으로 암산의 명수들에게 공통적으로 주어지는 문제가 바로 자연수를 넷 혹은 그 이하의 제곱수 합으로 나타내라는 것이었다. 1900년대 초반에 한 암산가가 15663 = 1252 + 62 + 12 + 12라는 해를 구하는데 8초가 걸렸다는 보고가 있다.좀 더 어려운 문제에 대해서는 56초가 걸렸다 : 11339 = 1052 + 152 + 82 + 52.
//
//자연수 n이 주어질 때, n을 최소 개수의 제곱수 합으로 표현하는 컴퓨터 프로그램을 작성하시오.

//
//문제풀이
//처음에 풀 때는
//단순히 가장 큰 제곱수를 뺀 dp값이 답이라고 생각했다.
//예를 들어 11이라는 수가 주어진다면
//가장 큰 제곱수는 9이다.
//11 - 9 = 2이고 dp[2] + 1이 최소일거라 생각했다.
//
//하지만 23같은 경우는
//16 + 4 + 1 + 1 + 1 보다
//9 + 9 + 4 + 1이 더 작다.그러므로 위의 방법은 틀렸다.
//
//이 문제는 탐색의 과정도 필요하다.
//아까 23을 다시 살펴보자
//23보다 작은 제곱수들을 다 보는 것이다.
//1, 4, 9, 16이 있으면 23에서 해당 값들을 뺀 값인
//dp[22], dp[19], dp[14], dp[7] 중에서
//가장 작은 값에 + 1을 해준 값이 dp[23]이 된다.
//
//예를들어 dp[7]를 골랐다면
//23은 16 + 4 + 1 + 1 + 1로 5가 되는 것이고
//dp[22]를 골랐다면 9 + 9 + 4 + 1로 4가 되는 것이다.


int dp[50001] = { 0 };

int main(void)
{

	ios_base::sync_with_stdio(0);
	cin.tie(0);

	int n;
	cin >> n;

	dp[1] = 1;

	for (int i = 2; i <= n; i++)
	{
		int minNumber = INT_MAX;
		for (int j = 1; j * j <= i; j++)
		{
			int temp = i - j * j;
			minNumber = min(minNumber, dp[temp]);
		}
		dp[i] = minNumber + 1;
	}

	cout << dp[n];


	return 0;

}
